# 设计模式
涵盖了七个面向对象设计原则和24个设计模式（23个GoF设计模式 + 
简单工厂模式）.


###   一、设计原则

1. 单一原则   
    定义：单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，
    或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
    
2. 开闭原则    
    定义： 一个软件实体应当对扩展开放，对修改关闭。
    即软件实体应尽量在不修改原有代码的情况下进行扩展。

3. 里氏代换原则    
    定义： 所有引用基类（父类）的地方必须能透明地使用其子类的对象。
    
4. 依赖倒转原则      
    定义： 抽象不应该依赖于细节，细节应当依赖于抽象。
    换言之，要针对接口编程，而不是针对实现编程。
        
    ```
    在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过
    依赖注入(DependencyInjection, DI)的方式注入到其他对象中，
    依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。
    常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。
    构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入
    具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。
    这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，
    由子类对象来覆盖父类对象。
    ```
    开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段

5. 接口隔离原则    
    定义：使用多个专门的接口，而不使用单一的总接口，
    即客户端不应该依赖那些它不需要的接口。

6. 合成复用原则
    定义： 尽量使用对象组合，而不是继承来达到复用的目的。
    简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。
7. 迪米特法则   
    定义： 一个软件实体应当尽可能少地与其他实体发生相互作用。
    
    
设计模式： 
    6种创建型模式、7种结构型、11种行为型    
  1. 简单工厂-- 不是23种模式     
    定义一个工厂类，它可以根据参数的不同返回不同类的实例，
    被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，
    因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。
  
  2. 工厂方法模式 -- 创建型模式    
    工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。
    工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，
    又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。
    工厂方法模式是一种类创建型模式。
    
   3. 抽象工厂模式  --创建型    
    与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，它负责创建一族产品。
    抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，
    而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。
    在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，
    这些产品构成了一个产品族，抽象工厂模式结构如图5所示：
    
  4. 单例模式 --确保对象的唯一性    
      通过复制现有的对象实例来创建新的对象实例。
    
  5. 原型模式 - 对象的克隆    
     通过复制现有的对象实例来创建新的对象实例。
    
  6. 建造者模式/生成器模式  -复杂对象的组装与创建    
    将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    生成器模式利用一个导演者对象和具体建造者对象一个一个地建造出所有的零件，从而建造出完整的对象。
    
  结构型模式 7 
  
  1. 适配器模式 -- 不兼容结构的协调  
    将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
  
  2. 桥接模式  -- 处理多维度变化    
    桥接模式 (Bridge)将抽象部分与实现部分分离，使它们都可以独立的变化。
  
  3. 组合模式 -- 树形结构的处理    
     组合模式又叫做部分-整体模式,它使我们树型结构的问题中,模糊了简单元素和复杂元素的概念,
     客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解藕.
  
  4. 装饰模式 -- 扩展系统功能 
      在不必改变原类文件和原类使用的继承的情况下，动态地扩展一个对象的功能。
    它是通过创建一个包装对象，也就是用装饰来包裹真实的对象来实现。
  
  5. 外观模式 -- 提供统一接口 
      为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
      
  6. 享元模式 -- 实现对象的复用    
      运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，
      可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，
      因此它又称为轻量级模式，它是一种对象结构型模式。
      
  7. 代理模式 -- 控制对象的访问    
     为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，
     一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用.
     
     静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。
     动态代理是在运行时，动态的生成字节码文件，对相应的接口进行代理，应用与hibernate、Spring、mybatis等框架中
     
     
  
  行为型模式 11个
  
  1. 职责链模式 --请求的链式处理  
      定义： 使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。
      将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。
  
  2. 命令模式 -- 请求发送者与接收者解耦    
      定义： 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，
      对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。
      每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；
      接收的一方收到请求，并执行相应的操作。
      请求发出端执行命令execute(), 命令类执行接受者的业务方法
      
  3. 解释器模式 -- 自定义语言的实现  
      定义： 给定一种语言，定义他的文法的一种表示，
      并定义一个解释器，该解释器使用该表示来解释语言中句子。
      
  4. 迭代器模式 -- 遍历聚合对象中的元素    
      定义：提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。
      
  5. 中介者模式 -- 协调多个对象之间的交互   
      定义：用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，
      从而使耦合松散，而且可以独立地改变它们之间的交互。
      
  6. 备忘录模式 -- 撤销功能的实现   
      定义：在不破坏封装性的前提下，捕获一个对象的内部状态，
      并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。
      
  7. 观察者模式 --对象间的联动 
      定义：定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，
      则所有依赖于它的对象都会得到通知并自动更新。
      
  8. 状态模式 --处理对象的多种状态及其相互转换 
     定义： 
     当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。
     状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。
     状态模式是一种对象行为型模式。
      
  9. 策略模式 -- 算法的封装与切换   
      定义：定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。
      
  10. 模板方法模式 --     
      定义：定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。
      
  11. 访问者模式 -- 操作复杂对象结构 
      定义：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
  
      
   
    
    
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    
    
    